/**
 * @file StaticContentPlugin.cpp
 *
 * This is a plug-in for the Excalibur web server, designed
 * to serve static content (e.g. files) in response to resource requests.
 *
 * © 2024 by Hatem Nabli
 */

#include <inttypes.h>
#include <Http/IServer.hpp>
#include <Json/Json.hpp>
#include <StringUtils/StringUtils.hpp>
#include <SystemUtils/File.hpp>
#include <WebServer/PluginEntryPoint.hpp>
#include <functional>

#ifdef _WIN32
#    define API __declspec(dllexport)
#else /* POSIX */
#    define API
#endif /* _WIN32 / POSIX */

namespace
{
    /**
     * This represents one space of server resources and how they
     * should be mapped to the file system.
     */
    struct SpaceMapping
    {
        /**
         * This is the path to the resource space in the server.
         */
        std::vector<std::string> space;

        /**
         * This is the file system path to the files to be served
         */
        std::string root;

        /**
         * This is the function to call in order to unregister
         * the plug-in as handling this server resource space.
         */
        Http::IServer::UnregistrationDelegate unregisterationDelegate;
    };

    /**
     * This function configures the given space mapping from the given
     * configuration items.
     *
     * @param[in, out] spaceMapping
     *      This is the space mapping to configure.
     *
     * @param[in] configuration
     *      This contains the items used to configure the space mapping.
     *
     * @param[in] diagnosticMessageDelegate
     *      This is the function to call to deliver diagnostic
     *      messages generated by the plug-in.
     * @return
     *      An indication of whether or not the space mapping
     *      was successfully configured is returned.
     */
    bool ConfigureSpaceMapping(
        SpaceMapping& spaceMapping, Json::Value configuration,
        SystemUtils::DiagnosticsSender::DiagnosticMessageDelegate diagnosticMessageDelegate) {
        // Determine the resource space we're serving.
        Uri::Uri uri;
        if (!configuration.Has("space"))
        {
            diagnosticMessageDelegate("", SystemUtils::DiagnosticsSender::Levels::ERROR,
                                      "no 'space' URI in configuration");
            return false;
        }
        if (!uri.ParseFromString(configuration["space"]))
        {
            diagnosticMessageDelegate("", SystemUtils::DiagnosticsSender::Levels::ERROR,
                                      "unable to parse 'space' URI in configuration");
            return false;
        }
        spaceMapping.space = uri.GetPath();
        (void)spaceMapping.space.erase(spaceMapping.space.begin());

        // Detrmine where to locate the static content.
        if (!configuration.Has("root"))
        {
            diagnosticMessageDelegate("", SystemUtils::DiagnosticsSender::Levels::ERROR,
                                      "no 'root' URI in confuguration");
            return false;
        }
        spaceMapping.root = (std::string)configuration["root"];
        if (!SystemUtils::File::IsAbsolutePath(spaceMapping.root))
        {
            spaceMapping.root =
                SystemUtils::File::GetExeParentDirectory() + "/" + spaceMapping.root;
        }
        return true;
    }
}  // namespace

/**
 * This is the type expected for the entry point function
 * for all server plug-ins
 *
 * @param[in, out] server
 *      This is the server to which to add the plugin.
 *
 * @param[in] configuration
 *      This holds the configuration items of the plugin.
 *
 * @param[in] diagnosticMessageDelegate
 *      This is the function to call to delliver à diagnostic message.
 *
 * @param[in, out] unloadDelegate
 *      This is the funcntion to call in order to unloade the plugin.
 *      if this is set to nullptr on return, it means the plug-in was
 *      unable to load successfully.
 */
extern "C" API void LoadPlugin(
    Http::IServer* server, Json::Value configuration,
    SystemUtils::DiagnosticsSender::DiagnosticMessageDelegate diagnosticMessageDelegate,
    std::function<void()>& unloadDelegate) {
    std::vector<SpaceMapping> spaceMappings;
    if (configuration.Has("spaces") &&
        (configuration["spaces"].GetType() == Json::Value::Type::Array))
    {
        const auto spaces = configuration["spaces"];
        for (size_t i = 0; i < spaces.GetSize(); ++i)
        {
            SpaceMapping spaceMapping;
            if (!ConfigureSpaceMapping(spaceMapping, spaces[i], diagnosticMessageDelegate))
            { return; }
            spaceMappings.push_back(std::move(spaceMapping));
        }
    } else
    {
        SpaceMapping spaceMapping;
        if (!ConfigureSpaceMapping(spaceMapping, configuration, diagnosticMessageDelegate))
        { return; }
        spaceMappings.push_back(std::move(spaceMapping));
    }

    for (auto& spaceMapping : spaceMappings)
    {
        auto root = spaceMapping.root;
        spaceMapping.unregisterationDelegate = server->RegisterResource(
            spaceMapping.space,
            [root](const std::shared_ptr<Http::IServer::Request> request,
                   std::shared_ptr<Http::Connection> connection, const std::string& trailer)
            {
                const auto path = StringUtils::Join(
                    {root, StringUtils::Join(request->target.GetPath(), "/")}, "/");

                SystemUtils::File file(path);
                auto response = std::make_shared<Http::Client::Response>();
                if (file.IsExisting() && !file.IsDirectory())
                {
                    if (file.OpenReadOnly())
                    {
                        SystemUtils::File::Buffer buffer(file.GetSize());
                        if (file.Read(buffer) == buffer.size())
                        {
                            // TODO replace it with something that gives
                            // a strong entity tag -- this one is weak
                            uint32_t sum = 0;
                            for (auto b : buffer)
                            { sum += b; }
                            const auto etag = StringUtils::sprintf("%" PRIu32, sum);
                            if (request->headers.HasHeader("If-None-Match") &&
                                (request->headers.GetHeaderValue("If-None-Match") == etag))
                            {
                                response->statusCode = 304;
                                response->status = "Not Modified";
                            } else
                            {
                                response->statusCode = 200;
                                response->status = "OK";
                                response->body.assign(buffer.begin(), buffer.end());
                            }
                            bool isGzipped = false;
                            if ((path.length() >= 5) && (path.substr(path.length() - 5) == ".html"))
                            {
                                response->headers.AddHeader("Content-Type", "text/html");
                                isGzipped = true;
                            } else if ((path.length() >= 3) &&
                                       (path.substr(path.length() - 3) == ".js"))
                            {
                                response->headers.AddHeader("Content-Type",
                                                            "application/javascript");
                                isGzipped = true;
                            } else if ((path.length() >= 4) &&
                                       (path.substr(path.length() - 4) == ".css"))
                            {
                                response->headers.AddHeader("Content-Type", "text/css");
                                isGzipped = true;
                            } else if ((path.length() >= 4) &&
                                       (path.substr(path.length() - 4) == ".txt"))
                            {
                                response->headers.AddHeader("Content-Type", "text/plain");
                                isGzipped = true;
                            } else if ((path.length() >= 4) &&
                                       (path.substr(path.length() - 4) == ".ico"))
                            {
                                response->headers.AddHeader("Content-Type", "image/x-icon");
                            } else
                            { response->headers.AddHeader("Content-Type", "text/plain"); }
                            if ((request->headers.HasHeaderToken("Accept-Encoding", "gzip")) &&
                                isGzipped)
                            {
                                response->headers.SetHeader("Content-Encoding", "gzip");
                                StringUtils::Join({etag, "-gzip"}, ",");
                            }
                            response->headers.AddHeader("Etag", etag);
                        } else
                        {
                            response->statusCode = 500;
                            response->status = "Unable to read the file";
                            response->headers.AddHeader("Content-Type", "text/plain");
                            response->body =
                                StringUtils::sprintf("Error reading file '%s'", path.c_str());
                        };
                    } else
                    {
                        response->statusCode = 500;
                        response->status = "Unable to open the file";
                        response->headers.AddHeader("Content-Type", "text/plain");
                        response->body =
                            StringUtils::sprintf("Error opening the file '%s'", path.c_str());
                    }
                } else
                {
                    response->statusCode = 404;
                    response->status = "Not Found";
                    response->headers.AddHeader("Content-Type", "text/plain");
                    response->body = StringUtils::sprintf("File '%s' not found.", path.c_str());
                }
                response->headers.AddHeader("Content-Length",
                                            StringUtils::sprintf("%zu", response->body.length()));
                return response;
            });
    }
    unloadDelegate = [spaceMappings]
    {
        for (const auto& spaceMapping : spaceMappings)
        { spaceMapping.unregisterationDelegate(); }
    };
}

/**
 * This checks to make sure the plug-in entry point signature
 * matches the entry point type declared in the web server API.
 */
namespace
{
    PluginEntryPoint EntryPoint = &LoadPlugin;
}  // namespace
